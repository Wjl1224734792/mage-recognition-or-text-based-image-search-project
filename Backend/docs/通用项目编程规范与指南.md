#  通用项目编程规范与指南

## 1. 代码规范

### 1.1 注释规范 📝

#### JavaScript (JSDoc)
```javascript
/**
 * 获取用户信息
 * @param {string} userId - 用户ID
 * @param {Object} options - 选项参数
 * @param {boolean} [options.includeProfile=true] - 是否包含用户资料
 * @returns {Promise<User>} 用户对象
 * @throws {Error} 当用户不存在时抛出错误
 */
async function getUser(userId, options = {}) {
  // 实现逻辑
}
```

#### TypeScript
```typescript
/**
 * 获取用户信息
 * @param userId - 用户ID
 * @param options - 选项参数
 * @returns 用户对象
 */
async function getUser(userId: string, options: GetUserOptions = {}): Promise<User> {
  // 实现逻辑
}
```

* 注释原则：
  * **必要性**：避免冗余注释（如 "定义变量 a" 这类无意义注释）
  * **详尽性**：关键逻辑（如边界条件、算法思路）需详细说明
  * **目的**：提升代码可读性和可维护性

### 1.2 嵌套层级限制 🎯

#### 核心原则
- **优秀**：1-3层嵌套
- **可接受**：4层嵌套（需有充分理由）
- **禁止**：超过4层嵌套

#### 1.2.1 提前返回模式 (Guard Clauses)

**基本模式**
```javascript
// ❌ 不推荐 - 深层嵌套
function getUserData(userId) {
  if (userId) {
    const user = db.findUser(userId);
    if (user) {
      if (user.isActive) {
        if (user.hasPermission) {
          return user.data;
        }
      }
    }
  }
  return null;
}

// ✅ 推荐 - 提前返回
function getUserData(userId) {
  if (!userId) return null;
  
  const user = db.findUser(userId);
  if (!user) return null;
  if (!user.isActive) return null;
  if (!user.hasPermission) return null;
  
  return user.data;
}
```

#### 1.2.2 函数提取策略

**条件提取**
```javascript
// ❌ 不推荐 - 复杂条件嵌套
function canUserAccessFeature(user, feature) {
  if (user) {
    if (user.subscription) {
      if (user.subscription.isActive) {
        if (feature.requiredLevel <= user.subscription.level) {
          return true;
        }
      }
    }
  }
  return false;
}

// ✅ 推荐 - 提取验证逻辑
function canUserAccessFeature(user, feature) {
  return hasValidSubscription(user) && 
         meetsFeatureRequirements(user, feature);
}

function hasValidSubscription(user) {
  return user?.subscription?.isActive;
}

function meetsFeatureRequirements(user, feature) {
  return user.subscription.level >= feature.requiredLevel;
}
```

### 1.3 数组操作规范 🔄

**禁止使用会改变原数组的方法:**
* ❌ push, pop, shift, unshift
* ❌ splice, reverse, sort
* ❌ fill, copyWithin

**推荐使用返回新数组以及不改变原数组的方法:**

**返回新数组的方法:**
* ✅ map, filter, concat, slice
* ✅ toSpliced, toSorted, toReversed (ES2023+)
* ✅ flat, flatMap
* ✅ with (ES2023+)

**迭代方法 (不改变原数组):**
* ✅ reduce, reduceRight
* ✅ every, some
* ✅ find, findIndex, findLast, findLastIndex
* ✅ forEach

**检查方法 (不改变原数组):**
* ✅ includes
* ✅ indexOf, lastIndexOf
* ✅ entries, keys, values

**转换方法 (不改变原数组):**
* ✅ join
* ✅ toString, toLocaleString

**扩展运算符的使用 (推荐)/深克隆不可用:**
* ✅ **数组扩展** - 简化数组操作
  ```javascript
  // 创建新数组
  const newArray = [...oldArray, newItem];
  
  // 合并数组
  const merged = [...array1, ...array2];
  
  // 复制数组
  const copy = [...original];
  
  // 插入元素
  const inserted = [...array.slice(0, index), newItem, ...array.slice(index)];
  ```

* ✅ **对象扩展** - 简化对象操作
  ```javascript
  // 创建新对象
  const newObj = { ...oldObj, newProp: value };
  
  // 合并对象
  const mergedObj = { ...obj1, ...obj2 };
  
  // 更新属性
  const updated = { ...obj, prop: newValue };
  
  // 删除属性 (结合解构)
  const { removed, ...withoutRemoved } = obj;
  ```

* ✅ **函数剩余参数** - 获取不定数量参数
  ```javascript
  // 收集剩余参数为数组
  function processItems(first, second, ...rest) {
    console.log(first, second); // 前两个参数
    console.log(rest);          // 剩余参数组成的数组
  }
  
  // 在箭头函数中使用
  const sum = (...numbers) => numbers.reduce((acc, curr) => acc + curr, 0);
  
  // 解构配合剩余参数
  const [first, ...others] = array;
  const { name, ...otherProps } = obj;
  ```

**例外情况:**
* ✅ **数组为空时**可以使用 `push` 和 `shift`
  * 当数组为空时，这些操作不会影响现有数据，可以作为初始化操作使用
  * 一旦数组不为空，应严格遵守不可变原则

**使用示例:**
```javascript
// ✅ 推荐使用扩展运算符
const baseArray = [1, 2, 3];

// 添加元素
const withFour = [...baseArray, 4];

// 删除元素 (配合filter)
const withoutTwo = baseArray.filter(n => n !== 2);

// 更新元素
const updated = baseArray.map((n, i) => i === 1 ? 99 : n);

// 对象更新
const user = { name: 'John', age: 25 };
const updatedUser = { ...user, age: 26 };

// 函数参数处理
function formatMessage(header, ...items) {
  return `${header}: ${items.join(', ')}`;
}

// ✅ 允许 - 空数组初始化
const emptyArray = [];
emptyArray.push(1); // 允许，因为是空数组
```

### 1.4 代码设计原则 🏗️

* 遵循设计原则：
  * SOLID（单一职责、开闭原则等）
  * DRY（避免重复，相同逻辑抽离为工具函数）
  * KISS（保持简单，拒绝过度设计）
* 模块化设计：
  * 高内聚，低耦合
  * 功能独立，易于维护（单个模块职责不超过 3 个核心功能）

### 1.5 ES6 模块化规范 📦

#### 1.5.1 导入导出规范

**命名导出与导入**
​```javascript
// ✅ 推荐 - 命名导出
export const API_BASE_URL = 'https://api.example.com';
export function formatDate(date) { /* ... */ }
export class HttpClient { /* ... */ }

// ✅ 推荐 - 命名导入
import { API_BASE_URL, formatDate, HttpClient } from './utils.js';
```

**默认导出与导入**
​```javascript
// ✅ 推荐 - 单一主要功能的默认导出
export default class UserService {
  // 类实现
}

// ✅ 推荐 - 默认导入
import UserService from './services/UserService.js';
```

#### 1.5.2 模块组织原则

**按功能划分模块**
```javascript
// ✅ 推荐 - 功能内聚的模块
// services/UserService.js
export default class UserService {
  static async getUser(id) { /* ... */ }
  static async updateUser(user) { /* ... */ }
  static async deleteUser(id) { /* ... */ }
}

// utils/validation.js
export function isValidEmail(email) { /* ... */ }
export function isValidPassword(password) { /* ... */ }
export function validateUser(user) { /* ... */ }
```

**避免循环依赖**
```javascript
// ❌ 不推荐 - 循环依赖
// moduleA.js
import { funcB } from './moduleB.js';
export function funcA() { funcB(); }

// moduleB.js  
import { funcA } from './moduleA.js';
export function funcB() { funcA(); }

// ✅ 推荐 - 解耦循环依赖
// common.js
export function commonLogic() { /* ... */ }

// moduleA.js
import { commonLogic } from './common.js';
export function funcA() { commonLogic(); }

// moduleB.js
import { commonLogic } from './common.js';
export function funcB() { commonLogic(); }
```

#### 1.5.3 导入路径规范

```javascript
// ✅ 推荐 - 清晰的导入路径
import UserService from '@/services/UserService.js';  // 使用别名
import { formatDate } from '../utils/date.js';        // 相对路径
import { API_CONFIG } from '../../constants/config.js'; // 跨层级导入

// ❌ 不推荐 - 混乱的导入路径
import UserService from '../../../services/UserService.js'; // 过多层级
import { util1, util2, util3 } from './utils.js';          // 过多命名导入
```

#### 1.5.4 动态导入

```javascript
// ✅ 推荐 - 按需动态导入
async function loadFeature(featureName) {
  try {
    const module = await import(`./features/${featureName}.js`);
    return module.default;
  } catch (error) {
    console.error(`Failed to load feature: ${featureName}`, error);
    return null;
  }
}

// ✅ 推荐 - 代码分割
const HeavyComponent = lazy(() => import('./HeavyComponent.js'));
```

### 1.6 条件逻辑优化规范 🚥

#### 1.6.1 避免深层嵌套：使用卫语句 / 快速返回

* 原则：提前处理异常 / 边界条件，减少代码缩进层级

#### 1.6.2 替代多分支：使用对象映射 / Map

* 原则：用 "数据结构" 替代 switch 或多分支 if-else，提升可维护性

#### 1.6.3 逻辑运算符：合理使用 ??、||、&&

* 原则：明确运算符语义，避免 "假值覆盖" 问题

#### 1.6.4 可选链运算符（?.）：简化链式取值，避免空值报错

* 原则：替代多层 && 判空，减少冗余代码

#### 1.6.5 相等判断：强制使用 === 而非 ==

* 原则：避免 == 的 "隐式类型转换" 导致的逻辑错误

### 1.7 箭头函数使用规范 ➡️

* 核心原则：箭头函数没有独立的 `this` 绑定，以下场景禁止使用箭头函数：

#### 1.7.1 对象/Map 映射的方法定义
```javascript
// ❌ 不推荐
const user = {
  name: '张三',
  getName: () => this.name  // this 指向错误
};

// ✅ 推荐
const user = {
  name: '张三',
  getName: function() { 
    return this.name;  // this 正确指向 user
  }
};
```

#### 1.7.2 类的方法定义  
```javascript
// ❌ 不推荐
class User {
  constructor(name) {
    this.name = name;
  }
  
  getName = () => {
    return this.name;  // this 绑定问题
  }
}

// ✅ 推荐
class User {
  constructor(name) {
    this.name = name;
  }
  
  getName() {
    return this.name;  // this 正确绑定到实例
  }
}
```

### 1.8 Promise 操作规范 ⏳

#### 1.8.1 并行异步操作：按需选择 Promise 组合方法
```javascript
// 全部成功才继续
const [user, orders] = await Promise.all([getUser(), getOrders()]);

// 需要所有结果（无论成功失败）
const results = await Promise.allSettled(tasks);

// 只需第一个成功的结果
const resource = await Promise.any(cdnUrls);

// 超时控制
const result = await Promise.race([fetch(url), timeout(5000)]);
```

#### 1.8.2 Promise 链式优化：减少不必要的 await
```javascript
// ❌ 不推荐
async function fetchData() {
  const response = await fetch(url);
  const data = await response.json();
  return data;
}

// ✅ 推荐
function fetchData() {
  return fetch(url).then(response => response.json());
}
```

## 2. 例外情况处理

### 2.1 允许的例外

```javascript
// 1. 算法实现（如递归、树遍历）
function traverseTree(node, depth = 0) {
  if (!node) return;
  
  if (node.left) {           // 必要的嵌套
    traverseTree(node.left, depth + 1);
  }
  
  if (node.right) {          // 必要的嵌套  
    traverseTree(node.right, depth + 1);
  }
}

// 2. 性能关键代码（需有性能测试证明）
function optimizedProcessing(data) {
  // 深层嵌套但有明确的性能优势
  // 必须添加详细注释说明原因
}
```

### 2.2 例外条件
- 必须添加详细注释说明深层嵌套的原因
- 需要团队评审通过
- 必须有性能测试或功能必要性证明

## 3. 质量保证 ✅

### 3.1 代码提交前检查
* **语法检查**：括号匹配、变量定义、类型错误
* **逻辑检查**：边界条件覆盖、循环终止条件
* **风格检查**：符合注释、数组操作、条件逻辑规范

### 3.2 强制检查项
* **嵌套层级**：不超过 4 层（硬性限制）
* **模块化规范**：使用 ES6 模块语法，避免循环依赖
* **多分支处理**：3个及以上分支使用对象映射 / Map
* **链式取值**：必须使用可选链 `?.`
* **this绑定**：涉及 `this` 的函数不使用箭头函数
* **异步操作**：正确使用 Promise 组合方法
* **错误处理**：包含 `finally` 保底操作
* **注释规范**：JS项目使用JSDoc，TS项目使用TSDoc

## 4. 最佳实践总结

### 4.1 核心原则
- **扁平优于嵌套**：减少代码缩进层级
- **单一职责**：每个函数只做一件事
- **模块化设计**：高内聚低耦合的模块结构
- **明确意图**：命名和结构清晰表达代码目的
- **错误优先**：提前处理异常和边界条件

### 4.2 质量目标
✅ **提高代码质量** - 统一的标准和最佳实践  
✅ **提升开发效率** - 清晰的规范和工具支持  
✅ **降低维护成本** - 可读性强、结构清晰的代码  
✅ **促进团队协作** - 一致的编码风格和模式  

### 4.3 持续改进
- 定期进行代码审查
- 收集团队反馈优化规范
- 关注新技术和最佳实践
- 保持规范的实用性和可操作性

---

**记住**：好的代码是写给人看的，只是恰好能被机器执行。保持代码的清晰和简洁，是每个开发者的责任。

*版本：2.1.5 | 最后更新：2025-10-20*